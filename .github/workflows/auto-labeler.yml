name: auto-labeler

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - canary
  pull_request_review:
    types: [submitted, dismissed]

concurrency: ${{ github.workflow }}-${{ github.event.pull_request.number }}

permissions:
  contents: read
  issues: write
  pull-requests: write

env:
  APPROVAL_THRESHOLD: "1"
  TARGET_BRANCH: "canary"

jobs:
  label-pr:
    runs-on: ubuntu-latest
    if: github.event.pull_request.base.ref == 'canary'

    steps:
      - name: Checkout PR head
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Label impacted packages/apps
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            const { execSync } = require('child_process');

            const { number: prNumber } = context.payload.pull_request;
            const { owner, repo } = context.repo;

            // Configuration
            const config = {
              topLevelDirs: ['api', 'packages', 'marketing', 'web'],
              colors: {
                api: '9333ea',
                marketing: '10b981',
                packages: '3b82f6',
                web: 'f97316',
                docker: '0ea5e9',
                scripts: '8b5cf6',
                workflows: 'ec4899',
                docs: '14b8a6',
                config: '6b7280',
              },
            };

            // Find all package.json files
            const findPackageJsonFiles = () => {
              try {
                const tempScript = `
                  const { globby } = await import('globby');
                  const paths = await globby(['**/package.json'], {
                    ignore: ['**/node_modules/**', '**/.git/**'],
                    absolute: false
                  });
                  console.log(JSON.stringify(paths));
                `;
                fs.writeFileSync('/tmp/find-packages.mjs', tempScript);
                const output = execSync('bun /tmp/find-packages.mjs', {
                  encoding: 'utf-8',
                  cwd: process.cwd()
                });
                fs.unlinkSync('/tmp/find-packages.mjs');
                return JSON.parse(output.trim());
              } catch {
                // Fallback to find command
                const output = execSync(
                  'find . -name "package.json" -type f -not -path "*/node_modules/*" -not -path "*/.git/*"',
                  { encoding: 'utf-8', cwd: process.cwd() }
                );
                return output
                  .split('\n')
                  .filter(Boolean)
                  .map(p => p.replace(/^\.\//, ''));
              }
            };

            // Build package directory map
            const buildPackageMap = (packageJsonPaths) => {
              const map = new Map();
              for (const packageJsonPath of packageJsonPaths) {
                const packageDir = path.dirname(packageJsonPath);
                const [topLevel, packageName] = packageDir.split('/').filter(Boolean);
                if (config.topLevelDirs.includes(topLevel) && packageName) {
                  map.set(packageDir, `@${topLevel}/${packageName}`);
                }
              }
              return map;
            };

            // Pattern matching: determine label for a file path
            const getLabelForFile = (filePath, packageMap) => {
              const pathParts = filePath.split('/').filter(Boolean);
              const fileName = pathParts[pathParts.length - 1];
              const [topLevel, secondLevel, ...rest] = pathParts;

              // Pattern 1: Dockerfiles → @docker
              if (fileName === 'Dockerfile' || fileName.startsWith('Dockerfile.')) {
                return '@docker';
              }

              // Pattern 2: Root config files → @config
              if (pathParts.length === 1) {
                return '@config';
              }

              // Pattern 3: File belongs to a tracked package/app
              if (config.topLevelDirs.includes(topLevel)) {
                for (let i = pathParts.length; i > 0; i--) {
                  const dirPath = pathParts.slice(0, i).join('/');
                  if (packageMap.has(dirPath)) {
                    return packageMap.get(dirPath);
                  }
                }
                // In tracked dir but no package.json found - use category name
                return `@${topLevel}`;
              }

              // Pattern 4: Specific directory mappings
              if (topLevel === '.github') {
                if (secondLevel === 'scripts') return '@scripts';
                if (secondLevel === 'workflows') return '@workflows';
                return '@workflows'; // Default for other .github files
              }

              if (topLevel === 'marketing' && secondLevel === 'docs') {
                return '@docs';
              }

              // Pattern 5: Other untracked directories - use directory name
              if (topLevel?.startsWith('.')) {
                return `@${topLevel.slice(1)}`;
              }
              return `@${topLevel}`;
            };

            // Ensure label exists
            const ensureLabel = async (labelName) => {
              try {
                await github.rest.issues.getLabel({ owner, repo, name: labelName });
              } catch (error) {
                if (error.status === 404) {
                  const category = labelName.includes('/') 
                    ? labelName.split('/')[0].substring(1)
                    : labelName.substring(1);
                  const color = config.colors[category] || '6b7280';
                  const description = `Auto-created label for ${labelName}`;
                  await github.rest.issues.createLabel({
                    owner,
                    repo,
                    name: labelName,
                    color,
                    description
                  });
                  console.log(`Created label: ${labelName}`);
                } else {
                  throw error;
                }
              }
            };

            // Main execution
            const packageJsonPaths = findPackageJsonFiles();
            console.log(`Found ${packageJsonPaths.length} package.json file(s)`);

            const packageMap = buildPackageMap(packageJsonPaths);
            const files = await github.paginate(
              github.rest.pulls.listFiles,
              { owner, repo, pull_number: prNumber, per_page: 100 }
            );

            // Collect labels using pattern matching
            const labelsToAdd = new Set();
            for (const file of files) {
              const label = getLabelForFile(file.filename, packageMap);
              labelsToAdd.add(label);
            }

            if (labelsToAdd.size === 0) {
              console.log('No files to label.');
              return;
            }

            console.log(`Labels to add: ${[...labelsToAdd].join(', ')}`);

            // Ensure all labels exist
            await Promise.all([...labelsToAdd].map(ensureLabel));

            // Get current labels and determine what to remove
            const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
              owner,
              repo,
              issue_number: prNumber
            });

            // Match all labels that start with @ and are not approval labels
            const labelPattern = /^@(api|packages|marketing|web|docker|scripts|workflows|docs|config|[\w-]+)(\/.+)?$/;
            const approvalPattern = /^\d+\/\d+$|^APPROVED$/;
            const toRemove = currentLabels
              .map(l => l.name)
              .filter(name => labelPattern.test(name) && !approvalPattern.test(name) && !labelsToAdd.has(name));

            // Remove stale labels
            for (const name of toRemove) {
              try {
                await github.rest.issues.removeLabel({
                  owner,
                  repo,
                  issue_number: prNumber,
                  name
                });
                console.log(`Removed stale label: ${name}`);
              } catch (error) {
                console.warn(`Failed to remove label ${name}:`, error.message);
              }
            }

            // Add new labels
            await github.rest.issues.addLabels({
              owner,
              repo,
              issue_number: prNumber,
              labels: [...labelsToAdd]
            });
            console.log(`Added labels: ${[...labelsToAdd].join(', ')}`);

      - name: Get approval count
        id: approvals
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          result-encoding: string
          script: |
            const pr = context.payload.pull_request;
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number
            });

            const latestReviewByUser = {};
            reviews
              .sort((a, b) => new Date(a.submitted_at) - new Date(b.submitted_at))
              .forEach(review => {
                if (review.user?.login) {
                  latestReviewByUser[review.user.login] = review;
                }
              });

            const approvers = Object.values(latestReviewByUser)
              .filter(review => review.state === 'APPROVED')
              .map(review => review.user.login);

            const count = approvers.length;
            console.log(`Found ${count} approval(s) from: ${approvers.join(', ') || 'none'}`);
            return count.toString();

      - name: Apply dynamic approval label
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            const { owner, repo } = context.repo;
            const count = parseInt(`${{ steps.approvals.outputs.result }}`, 10) || 0;
            const required = parseInt(process.env.APPROVAL_THRESHOLD, 10);

            const labelName = count >= required ? 'APPROVED' : `${count}/${required}`;
            const color = count >= required ? '0e8a16' : 'd73a4a';

            // Get existing labels
            const { data: existingLabels } = await github.rest.issues.listLabelsOnIssue({
              owner,
              repo,
              issue_number: pr.number
            });

            // Remove old approval labels
            const approvalPattern = /^\d+\/\d+$|^APPROVED$/;
            for (const label of existingLabels) {
              if (approvalPattern.test(label.name) && label.name !== labelName) {
                try {
                  await github.rest.issues.removeLabel({
                    owner,
                    repo,
                    issue_number: pr.number,
                    name: label.name
                  });
                  console.log(`Removed old approval label: ${label.name}`);
                } catch (error) {
                  console.warn(`Failed to remove label ${label.name}:`, error.message);
                }
              }
            }

            // Ensure label exists
            try {
              await github.rest.issues.getLabel({ owner, repo, name: labelName });
            } catch (error) {
              if (error.status === 404) {
                await github.rest.issues.createLabel({
                  owner,
                  repo,
                  name: labelName,
                  color,
                  description: count >= required
                    ? 'PR has met the required approvals'
                    : `PR has ${count} of ${required} required approvals`
                });
                console.log(`Created approval label: ${labelName}`);
              } else {
                throw error;
              }
            }

            // Add the label
            await github.rest.issues.addLabels({
              owner,
              repo,
              issue_number: pr.number,
              labels: [labelName]
            });
            console.log(`Applied approval label: ${labelName}`);
